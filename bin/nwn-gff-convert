#!/usr/bin/ruby
require 'rubygems'
require 'optparse'
require 'nwn/gff'
require 'nwn/helpers'
require 'nwn/yaml'
require 'nwn/kivinen'
require 'nwn/scripting'

Thread.abort_on_exception = true

$options = {
  :infile => '-',
  :outfile => '-',
  :informat => :auto,
  :outformat => :in,
  :verbose => false,
  :filters => [],
  :run => [],
  :safelevel => 0,
  :inferdatafile => ENV['NWN_LIB_INFER_DATA_FILE'],
}

FileFormats = [:gff, :yaml, :kivinen, :marshal]

GuessFormats = {
  /^ut[cdeimpstw]$/ => :gff,
  /^(git|are|gic)$/ => :gff,
  /^(mod|ifo|fac)$/ => :gff,
  /^(bic)$/ => :gff,
  /^ya?ml$/ => :yaml,
  /^marshal$/ => :marshal,
  /^k(ivinen)?$/ => :kivinen,
}

begin OptionParser.new do |o|
  o.banner = "Usage: nwn-gff-convert <options>"

  o.separator " "
  o.separator "File selection:"

  o.on "-i", "--infile FILE", "Input file (default: stdin)" do |f|
    $options[:infile] = f
  end
  o.on "-l, ""--infile-format FORMAT", [:auto] + FileFormats,
      "Input format (#{([:auto] + FileFormats).join(', ')})",
      "(default: auto - try to guess based on extension)" do |f|
    $options[:informat] = f
  end

  o.on "-o", "--outfile FILE", "Output file (default: stdout)" do |f|
    $options[:outfile] = f
  end
  o.on "-k", "--outfile-format FORMAT", [:in] + FileFormats,
      "Output format (#{([:in] + FileFormats).join(', ')})" do |f|
    $options[:outformat] = f
  end

  o.on "-t", "--types", "Show field types (kivinen format only)" do
    $options[:types] = true
  end

  o.on "--infer-data-file FILE", "Specify a .yml containing infer data",
      "(default: ENV variable NWN_LIB_INFER_DATA_FILE)" do |f|
    $options[:inferdatafile] = f
  end

  o.separator " "
  o.separator "Selection, Transformation:"

  o.on "-p", "--path PATH", "Only operate on the given path" do |path|
    $options[:path] = path
  end
  o.on "-m", "--modify FILTER", "Run code on tree nodes",
      " FILTER is 'regexp=code',",
      " where regexp is a regular expression,",
      " and code is any valid ruby code.",
      " Examples:",
      "   -m '/AddCost=self.field_value += 20'",
      " To see all pathes that would match",
      " your regular expression, use",
      "   -m 'your_rx='",
      " together with -v",
      "A special function 'log' is provided to print",
      "things to stderr." do |filter|
    $options[:filters] << filter
  end
  o.on "-r", "--run FILE", "Invoke a scriptfile.",
        "A special function 'log' is provided to print",
        "things to stderr." do |path|
    raise "Specified file (-r) does not exist: #{path}" unless
      FileTest.file?(path) && FileTest.readable?(path)
    $options[:run] << path
  end

  o.on "--safe-level LEVEL", %w{0 1 2 3 4},
      "Set a custom $SAFE level for -m and -r",
        "(0 to 4, default: #{$options[:safelevel]}, 0 means unrestricted)",
        "Please note that running 3rd party scripts can be",
        " D A N G E R O U S",
        "even with safe-level = 4. Do NOT RUN code",
        "you do not understand." do |f|
    $options[:safelevel] = f.to_i
  end

  o.separator " "
  o.separator "Common options:"

  o.on_tail "-h", "--help", "Show this crud" do
    puts o
    exit 1
  end

  o.on_tail "-v", "--verbose", "be verbose" do |v|
    $options[:verbose] = v
  end
end.parse!
rescue => ee
  $stderr.puts ee.to_s
  exit 1
end

ARGV.size == 0 or begin
  $stderr.puts "Too many arguments (try -h)."
  exit 1
end

def vputs *text
  $stderr.puts *text if $options[:verbose]
end

$options[:informat] or fail "No input format specified."
$options[:outformat] or fail "No output format specified."

if $options[:inferdatafile]
  vputs "Trying to load infer data file: #{$options[:inferdatafile]}"
  NWN::Gff.load_struct_defaults($options[:inferdatafile])
end

vputs "Reading: #{$options[:infile]}"
data_in = $options[:infile] == '-' ? $stdin.read : IO.read($options[:infile])

if :auto == $options[:informat]
  extension = File.extname($options[:infile])[1..-1]
  $options[:informat] = GuessFormats[GuessFormats.keys.select {|key| extension =~ key}[0]]
  fail "Cannot guess infile format from extension `#{extension}', specify with -l." unless
    $options[:informat]
end

$options[:outformat] = $options[:informat] if :in == $options[:outformat]

data_in = case $options[:informat]
  when :gff
    NWN::Gff::Reader.read(data_in)

  when :yaml
    YAML.load(data_in)

  when :marshal
    Marshal.load(data_in)

  when :kivinen
    fail "Reading kivinen-style data is not supported."

  else
    fail "bug"
end

# verify that we read a GFF struct
raise ArgumentError, "Input stream is NOT a valid gff struct" unless
  data_in.is_a?(NWN::Gff::Struct)

if path = $options[:path]
  vputs "Selecting path: #{path}"
  data_in = data_in.by_path(path)
end

original_hash = data_in.hash

$options[:filters].each {|filter|
  filter_path, filter_code = filter.split('=', 2)
  filter_rx = Regexp.new('^' + filter_path + '$')
#  vputs "Applying filter: #{path} = #{code}"

  data_in.each_by_flat_path {|path, field|
    if path =~ filter_rx
      vputs "Filter #{filter_path} matches #{path.inspect} .."
      t = Thread.new {
        include NWN
        include NWN::Gff::Scripting
        $SAFE = $options[:safelevel]
        field.instance_eval filter_code
      }.join
    end
  }
}

$options[:run].each {|file|
  $code = IO.read(file)
  $script = file
  vputs "Running script file: #{$script}"
  t = Thread.new {
    begin
      include NWN
      include NWN::Gff::Scripting
      $SAFE = $options[:safelevel]
      catch(:exit) { data_in.instance_eval($code) }
    end
  }.join
}

modified_hash = data_in.hash

if original_hash == modified_hash && $options[:outformat] == $options[:informat] &&
  File.expand_path($options[:outfile]) == File.expand_path($options[:infile]) && $options[:outfile] != "-"
  $stderr.puts "#{$options[:outfile]}: No need to write, data and filename would be the same."
  exit 0
end

write_to = $options[:outfile] == '-' ? $stdout : File.open($options[:outfile], 'w')

case $options[:outformat]
  when :gff
    write_to.print NWN::Gff::Writer.dump(data_in)

  when :yaml
    write_to.puts data_in.to_yaml

  when :marshal
    write_to.print Marshal.dump(data_in)

  when :kivinen
    data_in.kivinen_format $options[:types], nil, nil do |l,v|
      write_to.puts "%s:\t%s" % [l, v]
    end

  else
    fail "bug"
end

