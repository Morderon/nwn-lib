#!/usr/bin/ruby
require 'rubygems'
require 'optparse'
require 'nwn/gff'
require 'yaml'

format = nil

OptionParser.new do |o|
  o.banner = "Usage: nwn-gff-print [options] file/- [path]"
  o.on "-y", "--yaml", "Dump as yaml" do
    format = :yaml
  end
  o.on "-k", "--kivinen", "Dump as kivinens dump format (like the perl tools)" do
    format = :kivinen
  end
end.parse!

file = ARGV.shift or begin
  $stderr.puts "Required argument: filename to process, or - for stdin (try -h)."
  exit 1
end

path = ARGV.shift

if file == "-"
  bytes = $stdin.read
else
  bytes = IO.read(file)
end

g = NWN::Gff::Reader.read(bytes)

if path
  begin
    g = g[path]
  rescue Exception => e
    $stderr.puts "Error: " + e.to_s
    exit 1
  end
end

def k_format_struct s, prefix = "/", &block
  if s.is_a?(NWN::Gff::Gff)
    s = NWN::Gff::Element.new("", :struct, s.root_struct)
  end
  if s.is_a?(Array)
    v = NWN::Gff::Element.new("(unlabeled list)", :list, s)
  end
  if s.is_a?(NWN::Gff::Struct)
    s = NWN::Gff::Element.new("(unlabeled struct)", :struct, s)
  end
  case s.type
    when :struct
      s.value.each {|k,v|
    k_format_struct v, prefix + s.label + (s.label == "" ? "" : "/") do |l,v|
          yield(l, v)
    end
      }
    when :cexolocstr
      s.value.each {|vv|  
        yield(prefix + s.label + "/" + vv.language.to_s, vv.text)
      }
      yield(prefix + s.label + ". ___string_ref", s._str_ref)
    when :list
      s.value.each_with_index {|vv, idx|
        vv.each {|kkk, vvv|
          k_format_struct vvv, prefix + s.label + "[#{idx}]/" do |l,v|
            yield(l,v)
          end
        }
      }
    else
      yield(prefix + s.label, s.value)
  end
end

case format
  when :yaml
    y g
  when :kivinen
    k_format_struct g do |label, value|
      puts "%s:\t%s" % [label, value]
    end
  else
    puts "Unknown format; try -h"
end
